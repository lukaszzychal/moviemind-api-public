<?php

namespace App\Services;

/**
 * Validates AI-generated data against slug to prevent hallucinations and data inconsistencies.
 */
class AiDataValidator
{
    private const MIN_SIMILARITY_THRESHOLD = 0.6;

    private const MIN_MOVIE_YEAR = 1888;

    private const MAX_YEAR_OFFSET = 2; // current year + 2

    private const MIN_PERSON_BIRTH_YEAR = 1850;

    /**
     * Validate movie data generated by AI.
     *
     * @param  array<string, mixed>  $aiResponse  AI response data
     * @param  string  $slug  Movie slug
     * @return array<string, mixed> Returns array with keys: 'valid' (bool), 'errors' (array<string>), 'similarity' (float|null)
     */
    public function validateMovieData(array $aiResponse, string $slug): array
    {
        $errors = [];

        // 1. Validate release year
        if (isset($aiResponse['release_year'])) {
            $year = (int) $aiResponse['release_year'];
            $currentYear = (int) date('Y');
            $maxYear = $currentYear + self::MAX_YEAR_OFFSET;

            if ($year < self::MIN_MOVIE_YEAR || $year > $maxYear) {
                $errors[] = "Invalid release year: {$year} (expected ".self::MIN_MOVIE_YEAR."-{$maxYear})";
            }
        }

        // 2. Validate title similarity to slug
        $similarity = null;
        if (isset($aiResponse['title'])) {
            $similarity = $this->calculateSimilarity($slug, $aiResponse['title']);
            if ($similarity < self::MIN_SIMILARITY_THRESHOLD) {
                $errors[] = "Title '{$aiResponse['title']}' does not match slug '{$slug}' (similarity: ".number_format($similarity, 2).')';
            }
        }

        // 3. Extract year from slug and compare
        $yearPattern = '/\b(18[89]\d|19\d{2}|20[0-3]\d)\b/';
        if (preg_match($yearPattern, $slug, $matches) === 1) {
            $slugYear = (int) $matches[1];
            if (isset($aiResponse['release_year']) && $aiResponse['release_year'] != $slugYear) {
                $errors[] = "Release year mismatch: slug has {$slugYear}, AI returned {$aiResponse['release_year']}";
            }
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'similarity' => $similarity,
        ];
    }

    /**
     * Validate person data generated by AI.
     *
     * @param  array<string, mixed>  $aiResponse  AI response data
     * @param  string  $slug  Person slug
     * @return array<string, mixed> Returns array with keys: 'valid' (bool), 'errors' (array<string>), 'similarity' (float|null)
     */
    public function validatePersonData(array $aiResponse, string $slug): array
    {
        $errors = [];

        // 1. Validate birth date
        if (isset($aiResponse['birth_date'])) {
            $birthDate = \DateTime::createFromFormat('Y-m-d', $aiResponse['birth_date']);
            if (! $birthDate) {
                $errors[] = "Invalid birth date format: {$aiResponse['birth_date']}";
            } else {
                $year = (int) $birthDate->format('Y');
                $currentYear = (int) date('Y');

                if ($year < self::MIN_PERSON_BIRTH_YEAR || $year > $currentYear) {
                    $errors[] = "Invalid birth year: {$year} (expected ".self::MIN_PERSON_BIRTH_YEAR."-{$currentYear})";
                }
            }
        }

        // 2. Validate name similarity to slug
        $similarity = null;
        if (isset($aiResponse['name'])) {
            $similarity = $this->calculateSimilarity($slug, $aiResponse['name']);
            if ($similarity < self::MIN_SIMILARITY_THRESHOLD) {
                $errors[] = "Name '{$aiResponse['name']}' does not match slug '{$slug}' (similarity: ".number_format($similarity, 2).')';
            }
        }

        return [
            'valid' => empty($errors),
            'errors' => $errors,
            'similarity' => $similarity,
        ];
    }

    /**
     * Calculate similarity between slug and text using Levenshtein distance and word matching.
     *
     * @param  string  $slug  Slug to compare
     * @param  string  $text  Text to compare
     * @return float Similarity score between 0.0 and 1.0
     */
    private function calculateSimilarity(string $slug, string $text): float
    {
        // Normalize both strings
        $slugNormalized = $this->normalizeForComparison($slug);
        $textNormalized = $this->normalizeForComparison($text);

        // Use Levenshtein distance
        $maxLength = max(strlen($slugNormalized), strlen($textNormalized));
        if ($maxLength === 0) {
            return 1.0;
        }

        $distance = levenshtein($slugNormalized, $textNormalized);
        $similarity = 1 - ($distance / $maxLength);

        // Also check if slug words appear in text
        $slugWords = explode('-', $slugNormalized);
        $matchedWords = 0;
        $slugWordCount = count($slugWords);
        foreach ($slugWords as $word) {
            if (strlen($word) >= 3 && str_contains($textNormalized, $word)) {
                $matchedWords++;
            }
        }

        // @phpstan-ignore-next-line - explode always returns array with at least one element
        $wordSimilarity = $slugWordCount > 0 ? (float) ($matchedWords / $slugWordCount) : 0.0;

        // Combine both metrics (weighted average)
        return ($similarity * 0.6) + ($wordSimilarity * 0.4);
    }

    /**
     * Normalize text for comparison (remove year, lowercase, remove special chars).
     *
     * @param  string  $text  Text to normalize
     * @return string Normalized text
     */
    private function normalizeForComparison(string $text): string
    {
        // Remove year patterns
        $yearPattern = '/\b(18[89]\d|19\d{2}|20[0-3]\d)\b/';
        $text = (string) preg_replace($yearPattern, '', $text);

        // Convert to lowercase
        $text = strtolower($text);

        // Remove special characters, keep only alphanumeric and hyphens
        $text = (string) preg_replace('/[^a-z0-9-]/', '', $text);

        return trim($text, '-');
    }
}
