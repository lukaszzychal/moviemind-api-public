---
alwaysApply: true
---

# Zasady Pisania Kodu

## Filozofia: Pragmatyczne podejście

- Zasady są narzędziami, nie celem samym w sobie
- Czytelność > Zwięzłość
- Prosty kod jest lepszy niż "idealny" kod zgodny ze wszystkimi zasadami
- Nie stosuj zasad na siłę

## KISS (Keep It Simple, Stupid)

- **Prostota przed złożonością** - wybieraj prostsze rozwiązanie
- **Nie przesadzaj z abstrakcją** - czasem prosty kod jest lepszy
- **Unikaj przedwczesnej optymalizacji** - najpierw działający kod, potem optymalizacja
- **Czytelność > Wydajność** (w większości przypadków)
- **Najprostsze rozwiązanie które działa** jest najlepsze

## SOLID (stosuj pragmatycznie)

- **SRP**: Jedna klasa = jedna odpowiedzialność
- **OCP**: Otwórz na rozszerzenia, zamknij na modyfikacje
- **LSP**: Podklasy muszą być zastępowalne
- **ISP**: Interfejsy specyficzne, nie ogólne
- **DIP**: Zależność od abstrakcji, nie konkretnych implementacji

## DRY (Don't Repeat Yourself)

- Refaktoryzuj duplikację gdy występuje w 3+ miejscach
- Nie przesadzaj z abstrakcją - czasem duplikacja jest czytelniejsza
- Refaktoryzuj tylko gdy ma to praktyczny sens

## CUPID

- **C**omposable - łatwy do składania
- **U**nix philosophy - robi jedną rzecz dobrze
- **P**redictable - przewidywalny
- **I**diomatic - zgodny z Laravel conventions
- **D**omain-based - oparty na domenie

## Wybór Architektury

### Zasada: Start Simple, Scale When Needed

**Zacznij od prostego rozwiązania, dodaj złożoność tylko gdy jest to uzasadnione.**

### Proste rozwiązania (Skrypty Transakcji, Transaction Script)

**Używaj gdy:**
- ✅ Mały do średniego projektu (MVP, prototypy)
- ✅ Prosta logika biznesowa (CRUD, proste operacje)
- ✅ Mały zespół (1-3 osoby)
- ✅ Szybki development i delivery
- ✅ Niskie ryzyko zmian w wymaganiach
- ✅ Prosta domena (nie wymaga złożonej logiki biznesowej)

**Przykłady:**
- Laravel Controllers z bezpośrednim dostępem do Models
- Proste Services z logiką biznesową
- Repository pattern (jeśli potrzebny)
- Minimalna abstrakcja

**Zalety:**
- Szybki development
- Łatwe do zrozumienia
- Niskie koszty utrzymania (na początku)
- Szybka iteracja

### Zaawansowane architektury (DDD, Hexagonal, Clean Architecture)

**Używaj gdy:**
- ✅ Duży, złożony projekt
- ✅ Złożona logika biznesowa (wiele reguł, stanów)
- ✅ Wiele zespołów pracujących równolegle
- ✅ Długa żywotność projektu (5+ lat)
- ✅ Wysokie ryzyko zmian w wymaganiach
- ✅ Złożona domena (domain experts, rich domain model)
- ✅ Wymagana wysoka testowalność i izolacja
- ✅ Potrzeba wielu portów (API, CLI, Web, Events)

**Przykłady:**
- Domain-Driven Design (DDD) - Entities, Value Objects, Domain Services
- Hexagonal Architecture - Ports & Adapters
- Clean Architecture - warstwy z dependency rules
- CQRS + Event Sourcing (gdy potrzebne)

**Zalety:**
- Wysoka testowalność
- Lepsza separacja odpowiedzialności
- Łatwiejsze dodawanie nowych feature'ów
- Niezależność od frameworka
- Długoterminowa łatwość utrzymania

**Wady:**
- Więcej kodu (boilerplate)
- Wolniejszy initial development
- Więcej abstrakcji (może być trudniejsze do zrozumienia)
- Wyższe koszty na początku

### Migracja: Proste → Zaawansowane

**Kiedy refaktoryzować do bardziej zaawansowanej architektury:**

1. ✅ Kod staje się trudny do utrzymania
2. ✅ Trudno dodać nowe feature'y bez zmiany istniejących
3. ✅ Testy są trudne do napisania
4. ✅ Dużo duplikacji logiki biznesowej
5. ✅ Zespół rośnie i potrzebuje lepszej organizacji
6. ✅ Domena staje się bardziej złożona
7. ✅ Wymagana jest niezależność od frameworka

**Kiedy NIE refaktoryzować:**
- ❌ "Dla zasady" - bez konkretnego problemu
- ❌ Gdy kod działa dobrze i jest łatwy w utrzymaniu
- ❌ Gdy projekt jest mały i prosty
- ❌ Gdy nie ma czasu/resources na refaktoryzację

### Rekomendacje dla MovieMind API

**Obecny stan:**
- Prosta architektura z Services, Repositories, Controllers
- Event-Driven dla asynchronicznych operacji (Jobs)
- Laravel conventions

**Kiedy rozważyć DDD/Hexagonal:**
- Gdy logika biznesowa stanie się bardzo złożona
- Gdy będzie potrzeba wielu różnych portów (Web, CLI, Queue, Events)
- Gdy zespół urośnie i będzie potrzeba lepszej separacji
- Gdy będzie potrzeba niezależności od Laravel (np. shared kernel)

**Zasada:**
**Zacznij prosto, refaktoryzuj gdy pojawią się konkretne problemy, nie "na zapas".**

## GRASP (General Responsibility Assignment Software Patterns)

Wzorce GRASP pomagają przypisywać odpowiedzialności w projektowaniu obiektowym:

- **Information Expert** - przypisz odpowiedzialność klasie z informacją potrzebną do wykonania
- **Creator** - przypisz odpowiedzialność tworzenia klasie która używa/zawiera obiekt
- **Controller** - przypisz odpowiedzialność obsługi klasie reprezentującej system/fasadę
- **Low Coupling** - minimalizuj zależności między klasami
- **High Cohesion** - trzymaj powiązaną funkcjonalność razem
- **Polymorphism** - używaj polimorfizmu dla wariacji w zachowaniu
- **Pure Fabrication** - twórz klasy które nie reprezentują konceptów domenowych (np. Repository)
- **Indirection** - używaj pośrednich obiektów do rozluźnienia zależności
- **Protected Variations** - chroń przed wariacjami poprzez enkapsulację

## YAGNI (You Aren't Gonna Need It)

- **Nie dodawaj funkcjonalności dopóki nie jest potrzebna** - unikaj przedwczesnej abstrakcji
- **Rozwiązuj dzisiejsze problemy, nie jutrzejsze** - skup się na obecnych wymaganiach
- **Refaktoryzuj gdy potrzeba** - dodawaj złożoność tylko gdy jest konkretna potrzeba

## Code Smells (naprawiaj gdy utrudniają pracę)

### Smells strukturalne
- **God Class/Method** - klasa/metoda robi za dużo → podziel na mniejsze klasy/metody
- **Long Parameter List** - użyj DTO/Request object → utwórz obiekt parametrów
- **Feature Envy** - metoda używa więcej danych z innej klasy → przenieś metodę do tej klasy
- **Data Clumps** - grupy danych zawsze razem → użyj Value Object
- **Primitive Obsession** - używanie prymitywów zamiast obiektów → użyj Value Objects
- **Duplicate Code** - ten sam kod w wielu miejscach → wyciągnij do wspólnej metody/klasy
- **Long Method** - metoda jest za długa → wyciągnij metody
- **Large Class** - klasa ma za dużo odpowiedzialności → podziel na mniejsze klasy

### Smells behawioralne
- **Shotgun Surgery** - jedna zmiana wymaga wielu małych zmian → skonsoliduj powiązany kod
- **Divergent Change** - klasa zmienia się z wielu powodów → podziel odpowiedzialności
- **Parallel Inheritance Hierarchies** - podobne hierarchie dziedziczenia → połącz lub użyj kompozycji
- **Lazy Class** - klasa nie robi wystarczająco → wbuduj lub połącz z inną klasą
- **Speculative Generality** - kod na przyszłość który nie jest potrzebny → usuń (YAGNI)

### Smells zależności
- **Dependency Inversion Violation** - moduły wysokiego poziomu zależą od niskiego → użyj interfejsów/abstrakcji
- **Tight Coupling** - klasy zależą za bardzo od siebie → wprowadź interfejsy/abstrakcje
- **Circular Dependency** - klasy zależą od siebie → przerwij cykl

## Wzorce Projektowe (używaj gdy odpowiednie)

### Wzorce kreacyjne
- **Factory** - tworzenie obiektów bez określania dokładnej klasy
- **Builder** - konstruowanie złożonych obiektów krok po kroku
- **Singleton** - zapewnij tylko jedną instancję (używaj oszczędnie, preferuj dependency injection)

### Wzorce strukturalne
- **Repository** - abstrakcja warstwy dostępu do danych
- **Adapter** - spraw aby niekompatybilne interfejsy działały razem
- **Decorator** - dodawanie zachowania do obiektów dynamicznie
- **Facade** - uproszczony interfejs do złożonego podsystemu

### Wzorce behawioralne
- **Strategy** - zdefiniuj rodzinę algorytmów, uczyń je wymiennymi
- **Observer** - powiadamiaj wiele obiektów o zmianach stanu (Laravel Events)
- **Command** - enkapsuluj żądania jako obiekty (Laravel Jobs)
- **Template Method** - zdefiniuj szkielet algorytmu, pozwól podklasom wypełnić szczegóły

## Wzorce Architektoniczne

- **Repository Pattern** - abstrakcja dostępu do danych (już używany w projekcie)
- **Service Layer** - warstwa logiki biznesowej (już używana w projekcie)
- **Event-Driven** - komunikacja przez eventy (Laravel Events/Listeners)
- **CQRS** - oddzielenie modeli odczytu i zapisu (gdy potrzebne)
- **Hexagonal Architecture** - porty i adaptery (gdy potrzebne)
- **Clean Architecture** - reguła zależności z warstwami (gdy potrzebne)

## Zasady Refaktoryzacji i Optymalizacji

### Kiedy refaktoryzować
1. ✅ **Duplikacja kodu** - ta sama logika w 3+ miejscach
2. ✅ **Naruszenia zależności** - DIP, tight coupling
3. ✅ **Code smells** - God Class, Long Method, etc.
4. ✅ **Trudne do testowania** - trudno napisać testy jednostkowe
5. ✅ **Trudne do rozszerzenia** - dodawanie feature'ów wymaga wielu zmian
6. ✅ **Problemy z wydajnością** - zidentyfikowane wąskie gardła (najpierw zmierz!)

### Refaktoryzacja podczas rozwoju feature'ów
- **Zawsze refaktoryzuj dodając feature'y** - poprawiaj jakość kodu przyrostowo
- **Naprawiaj code smells gdy je napotkasz** - nie kumuluj długu technicznego
- **Stosuj SOLID/GRASP przy zmianach** - używaj zasad pragmatycznie
- **Wyciągaj wspólną logikę** - używaj Repository, Service, lub Trait gdy odpowiednie

### Wytyczne optymalizacji
- **Najpierw zmierz** - profiluj przed optymalizacją
- **Optymalizuj wąskie gardła** - skup się na rzeczywistych problemach wydajnościowych
- **Nie optymalizuj przedwcześnie** - najpierw działający kod, potem optymalizacja
- **Rozważ czytelność** - czytelny kod jest często wystarczająco szybki

## Feature Flags

### Typy flag

W projekcie używamy dwóch typów feature flag:

#### 1. Flagi produktowe (Product Flags)

**Charakterystyka:**
- Długoterminowe włączanie/wyłączanie funkcji w produkcji
- Kategorie: `core_ai`, `moderation`, `public_api`, `billing`, `i18n`, `performance`, `analytics`, `recommendations`, `operations`
- Mogą być `togglable: true` (zarządzane przez API admina)
- Domyślna wartość zależy od funkcji (często `true` dla core features)

**Przykłady:**
- `ai_description_generation` - core_ai, default: true, togglable: true
- `tmdb_verification` - moderation, default: true, togglable: true
- `public_jobs_polling` - public_api, default: true, togglable: true

**Kiedy używać:**
- Funkcje które mogą być włączane/wyłączane w produkcji
- Funkcje wymagające gradual rollout
- Funkcje które mogą wymagać szybkiego rollbacku

#### 2. Flagi developerskie (Developer Flags)

**Charakterystyka:**
- Tymczasowe flagi używane podczas developmentu
- Kategoria: `experiments`
- Zawsze `default: false` (domyślnie wyłączone)
- Zawsze `togglable: false` (nie można toggleować przez API - bezpieczeństwo)
- Opis zawiera słowa: "Experimental", "WIP", "Work in progress"

**Przykłady:**
- `generate_v2_pipeline` - experiments, default: false, togglable: false
- `description_style_packs` - experiments, default: false, togglable: false

**Kiedy używać:**
- Każda nowa lub ryzykowna funkcja zaburzająca stabilność
- Funkcje w trakcie developmentu (WIP)
- Eksperymentalne funkcje testowane przed wdrożeniem
- Funkcje które mogą powodować problemy w produkcji

### Lifecycle flag developerskich

1. **Tworzenie:**
   - Twórz flagę developerską wraz z rozpoczęciem pracy nad funkcją
   - Ustaw `category: 'experiments'`, `default: false`, `togglable: false`
   - Dodaj opis z informacją że to eksperymentalna funkcja

2. **Testowanie:**
   - Testuj funkcję ręcznie włączając flagę w środowisku dev/staging
   - NIE włączaj flag developerskich w produkcji
   - Używaj flag developerskich do izolacji nowych funkcji

3. **Wdrożenie:**
   - Po wdrożeniu funkcji do produkcji, **obowiązkowo usuń flagę developerską**
   - Usuń kod związany z flagą (warunki `Feature::active()`)
   - Usuń definicję flagi z `config/pennant.php`
   - Usuń klasę flagi z `app/Features/`
   - Zaktualizuj testy (usuń testy związane z flagą)

### Zasady nazewnictwa

- **Flagi produktowe:** opisowe nazwy funkcji (np. `ai_description_generation`, `tmdb_verification`)
- **Flagi developerskie:** nazwy z prefiksem eksperymentalnym lub sufiksem `_v2`, `_experimental` (np. `generate_v2_pipeline`)

### Dokumentacja

- Każda flaga musi mieć `description` w `config/pennant.php`
- Flagi developerskie muszą mieć w opisie informację o tymczasowym charakterze
- Po usunięciu flagi developerskiej, zaktualizuj dokumentację

### Przykład konfiguracji

```php
// Flaga produktowa
'ai_description_generation' => [
    'class' => ai_description_generation::class,
    'description' => 'Enables AI-generated movie/series descriptions.',
    'category' => 'core_ai',
    'default' => true,
    'togglable' => true,
],

// Flaga developerska
'generate_v2_pipeline' => [
    'class' => generate_v2_pipeline::class,
    'description' => 'Experimental v2 generation flow (WIP - remove after deployment).',
    'category' => 'experiments',
    'default' => false,
    'togglable' => false,
],
```

## Standardy kodowania

- **PSR-12** - formatowanie (enforced przez Pint)
- **Laravel Conventions** - konwencje Laravel
- **Type hints** - zawsze używaj typów
- **Strict types** - `declare(strict_types=1);` w plikach PHP
- **Return types** - zawsze określaj zwracany typ
- **Repository Pattern** - używaj Repository dla dostępu do danych, nie bezpośrednich zapytań Model w Jobach/Services
- **Dependency Injection** - preferuj constructor injection, używaj service container
