---
alwaysApply: true
---

# Workflow przed Commitem (WYMAGANE)

## Automatyczna instalacja Git HookÃ³w

**PRZED KAÅ»DYM COMMITEM LUB PUSHEM - automatycznie sprawdÅº i zainstaluj hooki:**

1. **SprawdÅº czy hooki sÄ… zainstalowane:**
   ```bash
   if [ ! -f ".git/hooks/pre-commit" ]; then
       if [ -f "scripts/git-hooks/pre-commit" ]; then
           cp scripts/git-hooks/pre-commit .git/hooks/pre-commit
           chmod +x .git/hooks/pre-commit
           echo "âœ… Git hooks installed automatically"
       fi
   fi
   ```

2. **Dla AI Agent:**
   - Przed kaÅ¼dym `git commit` lub `git push`, automatycznie sprawdÅº czy `.git/hooks/pre-commit` istnieje
   - JeÅ›li nie istnieje, automatycznie zainstaluj z `scripts/git-hooks/pre-commit`
   - Upewnij siÄ™, Å¼e hook ma uprawnienia wykonywania (`chmod +x`)
   - **NIE pytaj uÅ¼ytkownika - wykonaj automatycznie**

## Przed kaÅ¼dym commitem MUSISZ uruchomiÄ‡ i naprawiÄ‡:

### 1. Markdownlint (formatowanie Markdown) - jeÅ›li zmieniono pliki .md
```bash
# Automatyczna naprawa (uÅ¼ywa npx lub npm scripts)
npm run markdownlint:fix
# Lub dla konkretnych plikÃ³w
npx markdownlint-cli2-fix docs/issue/pl/TASKS.md

# Sprawdzenie
npm run markdownlint:check
```
**Instalacja:** `npm install` (markdownlint-cli2 jest w package.json) lub `./scripts/setup-markdownlint.sh`

### 2. Laravel Pint (formatowanie PHP)
```bash
cd api && vendor/bin/pint
```

### 3. PHPStan Fixer (analiza statyczna z auto-fix)
```bash
# UÅ¼yj PHPStan Fixer wrapper (uÅ¼ywa gÅ‚Ã³wnego autoloadera projektu)
cd api && ../scripts/phpstan-fixer-wrapper --phpstan-command="vendor/bin/phpstan analyse --memory-limit=2G --error-format=json" --mode=suggest

# Lub uÅ¼yj z istniejÄ…cym outputem JSON z PHPStan
cd api && vendor/bin/phpstan analyse --memory-limit=2G --error-format=json > phpstan-output.json 2>&1 || true
cd api && ../scripts/phpstan-fixer-wrapper --input=phpstan-output.json --mode=suggest
```

**Tryby:**
- `--mode=suggest` (domyÅ›lny) - Pokazuje co zostaÅ‚oby zmienione bez modyfikacji plikÃ³w (bezpieczne)
- `--mode=apply` - Faktycznie zapisuje zmiany do plikÃ³w (uÅ¼ywaj z ostroÅ¼noÅ›ciÄ…)

**Rekomendacja:** Zawsze najpierw uruchom z `--mode=suggest`, aby podglÄ…dnÄ…Ä‡ zmiany przed ich zastosowaniem.

Poziom: 5. Zero bÅ‚Ä™dÃ³w przed commitem.

#### Archiwizacja logÃ³w PHPStan
- Po kaÅ¼dym uruchomieniu PHPStan zapisz peÅ‚ny output (`stdout` + `stderr`) do pliku logÃ³w.
- UÅ¼ywaj katalogu `docs/logs/phpstan/` (utwÃ³rz przy pierwszym uÅ¼yciu, np. `mkdir -p docs/logs/phpstan`).
- Nazwa pliku: `phpstan-YYYYMMDD-HHMMSS.log` (np. `phpstan-20251109-153000.log`).
- Rekomendowane polecenie:
```bash
cd api && vendor/bin/phpstan analyse --memory-limit=2G 2>&1 | tee ../docs/logs/phpstan/phpstan-$(date +"%Y%m%d-%H%M%S").log
```
- Nie usuwaj istniejÄ…cych plikÃ³w logÃ³w â€” bÄ™dÄ… potrzebne w przyszÅ‚ych projektach.

### 3. PHPUnit (testy)
```bash
cd api && php artisan test
```
Wszystkie testy muszÄ… przechodziÄ‡.

### 4. Markdownlint (formatowanie Markdown) - **AUTOMATYCZNIE W PRE-COMMIT HOOK**

Pre-commit hook automatycznie uruchamia markdownlint-cli2-fix dla plikÃ³w .md przed commitem.

### 5. GitLeaks (sekrety) - **WYMAGANE PRZED COMMITEM I PUSHEM**
```bash
gitleaks protect --source . --verbose --no-banner
```
Zero wykrytych sekretÃ³w.

**WAÅ»NE:** Przed kaÅ¼dym commitem i pushem **ZAWSZE** uruchom GitLeaks. JeÅ›li GitLeaks nie jest zainstalowany, zainstaluj go:
```bash
# macOS
brew install gitleaks

# Lub uÅ¼yj skryptu instalacyjnego
./scripts/setup-pre-commit.sh
```

**Automatyczna instalacja hookÃ³w:**
- JeÅ›li hooki nie sÄ… zainstalowane, automatycznie zainstaluj je z `scripts/git-hooks/pre-commit`
- SprawdÅº czy `.git/hooks/pre-commit` istnieje, jeÅ›li nie - skopiuj z `scripts/git-hooks/pre-commit`
- Upewnij siÄ™, Å¼e hook ma uprawnienia wykonywania: `chmod +x .git/hooks/pre-commit`

### 6. Composer Audit (bezpieczeÅ„stwo)
```bash
cd api && composer audit
```
Napraw krytyczne luki przed commitem.

### 6. Aktualizacja Dokumentacji API (jeÅ›li zmieniono endpointy)
**WAÅ»NE:** JeÅ›li dodano/zmieniono/usuniÄ™to endpointy API, **ZAWSZE** zaktualizuj:

#### OpenAPI Spec
```bash
# Zaktualizuj docs/openapi.yaml
# Dodaj/zmieÅ„/usuÅ„ endpointy zgodnie ze zmianami w kodzie
```

#### Postman Collection
```bash
# Zaktualizuj docs/postman/moviemind-api.postman_collection.json
# Dodaj/zmieÅ„/usuÅ„ requesty zgodnie ze zmianami w API
```

#### Insomnia Collection
```bash
# Zaktualizuj docs/insomnia/moviemind-api-insomnia.json
# Dodaj/zmieÅ„/usuÅ„ requesty zgodnie ze zmianami w API
```

**Kiedy aktualizowaÄ‡:**
- âœ… Dodano nowy endpoint
- âœ… Zmieniono Å›cieÅ¼kÄ™ endpointu
- âœ… Zmieniono parametry requestu/response
- âœ… UsuniÄ™to endpoint
- âœ… Zmieniono status codes
- âœ… Dodano/zmieniono autoryzacjÄ™

**Format aktualizacji:**
- OpenAPI: Zgodnie z formatem OpenAPI 3.0
- Postman: JSON format zgodny z Postman Collection v2.1
- Insomnia: JSON format zgodny z Insomnia Export

### 7. Aktualizacja Instrukcji Manualnego Testowania (jeÅ›li zmieniono mechanizmy testowania)
**WAÅ»NE:** JeÅ›li zmieniono mechanizmy testowania, endpointy, feature flagi, format odpowiedzi lub strukturÄ™ logÃ³w, **ZAWSZE** zaktualizuj:

#### Manual Testing Guide
```bash
# Zaktualizuj docs/knowledge/reference/MANUAL_TESTING_GUIDE.md (PL)
# Zaktualizuj docs/knowledge/reference/MANUAL_TESTING_GUIDE.en.md (EN)
```

**Kiedy aktualizowaÄ‡:**
- âœ… Zmieniono endpointy API (dodano/zmieniono/usuniÄ™to)
- âœ… Zmieniono mechanizmy zapobiegania duplikatom (np. slot management, locking)
- âœ… Zmieniono feature flagi (dodano/zmieniono/usuniÄ™to)
- âœ… Zmieniono format odpowiedzi API
- âœ… Zmieniono wymagania dotyczÄ…ce slug formatÃ³w
- âœ… Zmieniono strukturÄ™ logÃ³w (np. nowe logi, zmiana formatu)
- âœ… Zmieniono sposÃ³b aktywacji feature flagÃ³w
- âœ… Dodano nowe scenariusze testowe

**Format aktualizacji:**
- Zaktualizuj odpowiednie sekcje testÃ³w
- Zaktualizuj przykÅ‚ady komend
- Zaktualizuj troubleshooting
- Zaktualizuj checklist koÅ„cowy
- Zaktualizuj datÄ™ "Ostatnia aktualizacja"

## Kompletny check (wszystko na raz)

# Markdown formatting (if .md files changed, optional - pre-commit hook does this automatically)
npm run markdownlint:fix && \
cd api && \
  vendor/bin/pint && \
  ../scripts/phpstan-fixer-wrapper --phpstan-command="vendor/bin/phpstan analyse --memory-limit=2G --error-format=json" --mode=suggest && \
  php artisan test && \
  cd .. && \
  gitleaks protect --source . --verbose --no-banner && \
  cd api && \
  composer audit
```

**Uwaga:** Pre-commit hook automatycznie uruchamia markdownlint dla plikÃ³w .md, wiÄ™c rÄ™czne uruchomienie jest opcjonalne.

**PamiÄ™taj:** Po zmianach w API zawsze zaktualizuj dokumentacjÄ™ (OpenAPI, Postman, Insomnia) oraz instrukcje manualnego testowania!

## Automatyczna instalacja Git HookÃ³w

**Przed kaÅ¼dym commitem lub pushem:**
1. SprawdÅº czy `.git/hooks/pre-commit` istnieje
2. JeÅ›li nie istnieje, automatycznie zainstaluj z `scripts/git-hooks/pre-commit`:
   ```bash
   cp scripts/git-hooks/pre-commit .git/hooks/pre-commit && chmod +x .git/hooks/pre-commit
   ```
3. SprawdÅº czy GitLeaks jest zainstalowany (`command -v gitleaks`)
4. JeÅ›li nie, poinformuj uÅ¼ytkownika o koniecznoÅ›ci instalacji (nie blokuj, ale ostrzeÅ¼)

**Automatyczna weryfikacja sekretÃ³w:**
- Przed kaÅ¼dym commitem: uruchom `gitleaks protect --source . --verbose --no-banner --staged`
- Przed kaÅ¼dym pushem: uruchom `gitleaks protect --source . --verbose --no-banner`
- JeÅ›li sekrety zostanÄ… wykryte, **BLOKUJ** commit/push i poinformuj uÅ¼ytkownika

## Branch Workflow (domyÅ›lna zasada)

- **90% zadaÅ„** realizuj na krÃ³tkich branchach feature (`feature/â€¦`) obejmujÄ…cych jeden spÃ³jny temat.
- KaÅ¼dy branch koÅ„cz pull requestem do `main` (moÅ¼esz zatwierdziÄ‡ sam, ale PR i diff sÄ… obowiÄ…zkowe).
- `main` musi pozostaÄ‡ zawsze deployowalny; merguj tylko po przejÅ›ciu testÃ³w/pre-commitÃ³w.
- DÅ‚uÅ¼sze, wielotygodniowe branche stosuj wyÅ‚Ä…cznie w wyjÄ…tkowych rekonstrukcjach â€” wtedy dziel pracÄ™ na mniejsze PR-y.
- **Commit messages** pisz wyÅ‚Ä…cznie po angielsku, w stylu `type: short description` (np. `feat: add movie resource`). Niedozwolone sÄ… komunikaty w innych jÄ™zykach.
- **Pull Request descriptions** (body) pisz wyÅ‚Ä…cznie po angielsku. Wszystkie opisy PR, tytuÅ‚y i sekcje muszÄ… byÄ‡ w jÄ™zyku angielskim. Niedozwolone sÄ… opisy PR w innych jÄ™zykach.
- Agent moÅ¼e wykonywaÄ‡ `git commit`, ale `git push` uruchamia wyÅ‚Ä…cznie na wyraÅºne polecenie uÅ¼ytkownika.

## Natychmiastowe commity

- Po kaÅ¼dej zmianie w plikach zasad Cursor (`.cursor/rules/*.mdc`) wykonaj natychmiastowy commit obejmujÄ…cy te pliki.
- Po dodaniu nowego zadania lub aktualizacji treÅ›ci istniejÄ…cego zadania w `docs/issue/**/*.md`, niezwÅ‚ocznie zatwierdÅº te zmiany w osobnym commicie.

## ZarzÄ…dzanie zadaniami (TASKS.md)

- Po rozpoczÄ™ciu zadania **zmieÅ„ status na `ğŸ”„ IN_PROGRESS`**, wpisz `Czas rozpoczÄ™cia` (z dokÅ‚adnoÅ›ciÄ… do minuty) oraz oznacz wykonawcÄ™ (`ğŸ¤–/ğŸ‘¨â€ğŸ’»/âš™ï¸`).
- Po zakoÅ„czeniu zadania:
  - uzupeÅ‚nij `Czas zakoÅ„czenia` oraz **oblicz `Czas realizacji`** (format `HHhMMm`), nawet gdy skrÃ³t mÃ³wi o AUTO,
  - zmieÅ„ status na `âœ… COMPLETED`,
  - **przenieÅ› caÅ‚y blok zadania do sekcji â€âœ… ZakoÅ„czone Zadaniaâ€**,
  - dopisz krÃ³tki opis wykonanych prac (np. lista kluczowych zmian).
- Nie zostawiaj ukoÅ„czonych zadaÅ„ w sekcji â€Aktywneâ€. Sekcja ta powinna zawieraÄ‡ wyÅ‚Ä…cznie zadania w statusie `â³` lub `ğŸ”„`.
- Po aktualizacji `TASKS.md` odpal workflow synchronizacji (push/merge do `main` lub rÄ™cznie w GitHub Actions), aby Issues byÅ‚y spÃ³jne.

## Dokumentacja (PL / EN)

- KaÅ¼dy dokument musi mieÄ‡ wersjÄ™ polskÄ… i angielskÄ… (np. w `docs/â€¦/pl` i `docs/â€¦/en`).
- Przy modyfikacji jednego jÄ™zyka **natychmiast** zaktualizuj drugi â€“ brak synchronizacji traktujemy jako bÅ‚Ä…d review.
- JeÅ›li treÅ›Ä‡ jest dÅ‚uga, dopuszczalne sÄ… streszczenia, ale oba jÄ™zyki muszÄ… zawieraÄ‡ komplet kluczowych informacji i linkowaÄ‡ do siebie.
- Pliki indeksowe (np. `docs/issue/README.md`) powinny jasno wskazywaÄ‡, gdzie znajdujÄ… siÄ™ wersje PL i EN.

## Linki zewnÄ™trzne i nazwy wÅ‚asne

- Przy podawaniu publicznie dostÄ™pnych nazw wÅ‚asnych (np. sklepy internetowe, dostawcy) **zawsze** doÅ‚Ä…cz obok wiarygodny link URL.
- KaÅ¼dy link zewnÄ™trzny **musisz zweryfikowaÄ‡** (otworzyÄ‡/testowo sprawdziÄ‡), aby upewniÄ‡ siÄ™, Å¼e jest aktywny i prowadzi do wÅ‚aÅ›ciwego ÅºrÃ³dÅ‚a.
- JeÅ›li nie moÅ¼esz potwierdziÄ‡ linku, **wyraÅºnie to zaznacz**, dodajÄ…c alternatywne ÅºrÃ³dÅ‚o lub ostrzeÅ¼enie.
- Odpowiedzi formatuj przejrzyÅ›cie (nagÅ‚Ã³wki, listy punktowane) zgodnie z guideline Cursor.

## Testowanie manualne

- **ZAWSZE** przetestuj manualnie taski i funkcje, ktÃ³re moÅ¼na przetestowaÄ‡ bez automatycznych testÃ³w.
- **Informuj na bieÅ¼Ä…co** o krokach i wynikach testowania:
  - Opisz kaÅ¼dy krok testowania (np. "TestujÄ™ endpoint GET /api/v1/movies/{slug}")
  - Podawaj wyniki kaÅ¼dego testu (sukces/bÅ‚Ä…d, status code, czas odpowiedzi, etc.)
  - Informuj o napotkanych problemach lub nieoczekiwanych zachowaniach
  - ZgÅ‚aszaj postÄ™p w testowaniu (np. "Przetestowano 3/5 scenariuszy")
- Przed zakoÅ„czeniem zadania zweryfikuj, Å¼e implementacja dziaÅ‚a poprawnie w praktyce (np. przez wywoÅ‚anie endpointu API, sprawdzenie odpowiedzi, weryfikacjÄ™ zachowania w przeglÄ…darce).
- JeÅ›li testowanie wymaga uruchomienia Dockera lub innego narzÄ™dzia (np. Redis, Horizon, PostgreSQL), **zawsze poinformuj uÅ¼ytkownika**:
  - Jakie narzÄ™dzie jest potrzebne
  - Jak je uruchomiÄ‡ (np. `docker compose up -d`, `php artisan horizon`)
  - Jakie komendy naleÅ¼y wykonaÄ‡ do weryfikacji
  - Gdzie sprawdziÄ‡ wyniki (logi, dashboard, etc.)
- PrzykÅ‚ady sytuacji wymagajÄ…cych testowania manualnego:
  - Nowe endpointy API (sprawdzenie odpowiedzi, status codes, format JSON)
  - Integracje z zewnÄ™trznymi serwisami (OpenAI, etc.)
  - Zmiany w UI/UX (jeÅ›li dotyczy)
  - FunkcjonalnoÅ›ci wymagajÄ…ce interakcji uÅ¼ytkownika
  - Scenariusze trudne do przetestowania automatycznie (np. race conditions, timing issues)
- JeÅ›li testowanie manualne nie jest moÅ¼liwe lub wymagaÅ‚oby zbyt duÅ¼o czasu, poinformuj uÅ¼ytkownika o tym i zaproponuj alternatywne podejÅ›cie (np. testy automatyczne, dokumentacja, etc.).

## Informowanie o modelu AI i tokenach

- **ZAWSZE** informuj uÅ¼ytkownika z jakiego modelu AI korzystasz na poczÄ…tku odpowiedzi lub gdy jest to istotne dla kontekstu.
- Format: `**Model AI uÅ¼ywany:** [nazwa modelu]` (np. `Claude Sonnet 4.5 (Auto)`, `OpenAI gpt-4o-mini`).
- JeÅ›li dostÄ™pne sÄ… informacje o tokenach (zuÅ¼yte/pozostaÅ‚e) i **ich podanie nie zuÅ¼ywa dodatkowych tokenÃ³w**, moÅ¼esz je doÅ‚Ä…czyÄ‡:
  - Format podstawowy: `**Tokeny:** zuÅ¼yte: X, pozostaÅ‚e: Y` (lub podobny, w zaleÅ¼noÅ›ci od dostÄ™pnych danych).
  - JeÅ›li dostÄ™pne sÄ… szczegÃ³Å‚owe informacje o tokenach dla prompt/response lub input/output, moÅ¼esz je podaÄ‡:
    - Format: `**Tokeny:** input: X, output: Y, total: Z` lub `**Tokeny:** prompt: X, response: Y, total: Z`
    - UwzglÄ™dnij tylko te informacje, ktÃ³re sÄ… dostÄ™pne i ktÃ³rych podanie nie zuÅ¼ywa dodatkowych tokenÃ³w.
- JeÅ›li informacja o tokenach nie jest dostÄ™pna lub jej podanie zuÅ¼ywaÅ‚oby dodatkowe tokeny, pomiÅ„ tÄ™ informacjÄ™.
- W kontekÅ›cie aplikacji MovieMind API, jeÅ›li wspominasz o modelu uÅ¼ywanym przez aplikacjÄ™ (np. OpenAI), zawsze podaj peÅ‚nÄ… nazwÄ™ modelu (np. `gpt-4o-mini`).
